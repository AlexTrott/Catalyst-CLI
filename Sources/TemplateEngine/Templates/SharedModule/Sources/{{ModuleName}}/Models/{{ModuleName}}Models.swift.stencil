//
//  {{ModuleName}}Models.swift
//  {{ModuleName}}
//
//  Created by {{Author|default:"Catalyst CLI"}} on {{Date|date:"MM/dd/yyyy"}}.
//  Copyright Â© {{Year}} {% if OrganizationName %}{{OrganizationName}}{% else %}All rights reserved{% endif %}.
//

import Foundation

// MARK: - Result Types

/// A generic result type for API responses
public struct APIResponse<T: Codable>: Codable {
    public let success: Bool
    public let data: T?
    public let message: String?
    public let error: APIError?

    public init(success: Bool, data: T? = nil, message: String? = nil, error: APIError? = nil) {
        self.success = success
        self.data = data
        self.message = message
        self.error = error
    }
}

/// API Error model
public struct APIError: Codable, LocalizedError {
    public let code: String
    public let message: String
    public let details: [String: String]?

    public init(code: String, message: String, details: [String: String]? = nil) {
        self.code = code
        self.message = message
        self.details = details
    }

    public var errorDescription: String? {
        message
    }
}

// MARK: - User Models

/// Basic user information model
public struct User: Codable, Identifiable {
    public let id: String
    public let username: String
    public let email: String
    public let firstName: String?
    public let lastName: String?
    public let avatarURL: URL?
    public let createdAt: Date
    public let updatedAt: Date

    public init(
        id: String,
        username: String,
        email: String,
        firstName: String? = nil,
        lastName: String? = nil,
        avatarURL: URL? = nil,
        createdAt: Date = Date(),
        updatedAt: Date = Date()
    ) {
        self.id = id
        self.username = username
        self.email = email
        self.firstName = firstName
        self.lastName = lastName
        self.avatarURL = avatarURL
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    public var fullName: String? {
        guard let firstName = firstName else { return nil }
        guard let lastName = lastName else { return firstName }
        return "\(firstName) \(lastName)"
    }
}

// MARK: - Configuration Models

/// App configuration model
public struct AppConfiguration: Codable {
    public let environment: Environment
    public let apiBaseURL: URL
    public let apiVersion: String
    public let features: [String: Bool]
    public let settings: [String: Any]

    public enum Environment: String, Codable {
        case development
        case staging
        case production
    }

    private enum CodingKeys: String, CodingKey {
        case environment
        case apiBaseURL
        case apiVersion
        case features
    }

    public init(
        environment: Environment,
        apiBaseURL: URL,
        apiVersion: String = "v1",
        features: [String: Bool] = [:],
        settings: [String: Any] = [:]
    ) {
        self.environment = environment
        self.apiBaseURL = apiBaseURL
        self.apiVersion = apiVersion
        self.features = features
        self.settings = settings
    }

    // Custom encoding/decoding for settings dictionary
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        environment = try container.decode(Environment.self, forKey: .environment)
        apiBaseURL = try container.decode(URL.self, forKey: .apiBaseURL)
        apiVersion = try container.decode(String.self, forKey: .apiVersion)
        features = try container.decode([String: Bool].self, forKey: .features)
        settings = [:] // Settings would need custom decoding if persisted
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(environment, forKey: .environment)
        try container.encode(apiBaseURL, forKey: .apiBaseURL)
        try container.encode(apiVersion, forKey: .apiVersion)
        try container.encode(features, forKey: .features)
    }
}

// MARK: - Pagination Models

/// Pagination information for list responses
public struct Pagination: Codable {
    public let page: Int
    public let pageSize: Int
    public let totalPages: Int
    public let totalItems: Int
    public let hasNext: Bool
    public let hasPrevious: Bool

    public init(
        page: Int,
        pageSize: Int,
        totalPages: Int,
        totalItems: Int
    ) {
        self.page = page
        self.pageSize = pageSize
        self.totalPages = totalPages
        self.totalItems = totalItems
        self.hasNext = page < totalPages
        self.hasPrevious = page > 1
    }
}

/// Paginated response wrapper
public struct PaginatedResponse<T: Codable>: Codable {
    public let items: [T]
    public let pagination: Pagination

    public init(items: [T], pagination: Pagination) {
        self.items = items
        self.pagination = pagination
    }
}

// MARK: - State Models

/// Generic loading state
public enum LoadingState<T> {
    case idle
    case loading
    case loaded(T)
    case error(Error)

    public var isLoading: Bool {
        if case .loading = self {
            return true
        }
        return false
    }

    public var value: T? {
        if case .loaded(let value) = self {
            return value
        }
        return nil
    }

    public var error: Error? {
        if case .error(let error) = self {
            return error
        }
        return nil
    }
}